/*!
 * xml-class-transformer v3.0.0
 * (c) Edgar Pogosyan
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("xml-js-v2")):"function"==typeof define&&define.amd?define(["exports","xml-js-v2"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self)["xml-class-transformer"]={},t.xmljs)}(this,(function(t,e){"use strict";function n(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var r=n(e);const o=new class{marshal(t){if(void 0!==t)return null===t?"":`${t}`}unmarshal(t){if(void 0===t)return;const e=`${t}`;return""===e?null:e?parseFloat(e):void 0}},i=new class{marshal(t){if(void 0!==t)return null===t?"":`${t}`}unmarshal(t){if(void 0===t)return;const e=`${t}`;return""===e?null:e?BigInt(e):void 0}},s=new class{marshal(t){if(void 0!==t)return null===t?"":`${t}`}unmarshal(t){if(void 0!==t)return`${t}`}},a=new class{marshal(t){if(void 0!==t)return null===t?"":`${t}`}unmarshal(t){if(void 0===t)return;const e=`${t}`;return""===e?null:e?"true"===e:void 0}},l=new class{marshal(t){if(void 0!==t)return null===t?"":t.toISOString()}unmarshal(t){if(void 0!==t)return""===t?null:new Date(t)}};function c(t){return new Error(`xml-class-transformer: class "${t}" not found. Make sure there is a @XmlElem({...}) decorator on it, or XmlChildElem, XmlAttribute, XmlChardata or XmlComments decorator on its properties.`)}function m(t){return new Error(`xml-class-transformer: no XML name is specified for ${null==t?void 0:t.name}. Specify it with the @XmlElem({ name: '...' }) decorator.`)}function u(t){return t===String||t===Number||t===BigInt||t===Boolean||t===Date}function f(t){switch(t){case String:return s;case Number:return o;case BigInt:return i;case Boolean:return a;case Date:return l}throw new Error("unknown primitive type "+t)}const p=new class{constructor(){this.registry=new Map}setEntityOptions(t,e){const n=this.registry.get(t);n?n.entity=e:this.registry.set(t,{entity:e,properties:new Map})}setPropertyOptions(t,e,n){const r=this.getOrCreate(t);if(n.comments)for(const[n,o]of r.properties)if(o.comments)throw new Error(`xml-class-transformer: only one @XmlComment() decorator is allowed per class. Can not define @XmlComment() decorator for  ${t.name}#${e} since it's already used for ${t.name}#${n}.`);if(n.name)for(const[o,i]of r.properties){if(i.name===n.name)throw new Error(`xml-class-transformer: can't use XML element name defined in { name: ${JSON.stringify(n.name)} } for ${t.name}#${e} since it's already used for ${t.name}#${o}. Change it to something else.`);if(n.chardata&&i.chardata)throw new Error(`xml-class-transformer: an XML element can have only one chardata property. Both ${t.name}#${e} and ${t.name}#${i.name} are defined as chardata, which is not valid.`)}r.properties.set(e,n)}getOrCreate(t){const e=this.registry.get(t);if(e)return e;{const e={entity:{name:null==t?void 0:t.name},properties:new Map};return this.registry.set(t,e),e}}get(t){return this.registry.get(t)}getWithInheritance(t){const e=this.registry.get(t);if(!e)return;const n={entity:Object.assign({},e.entity),properties:new Map(e.properties)};let r=Object.getPrototypeOf(t.prototype);for(;r&&r.constructor!==Object;){const t=r.constructor,e=this.registry.get(t);if(e)for(const[t,r]of e.properties.entries())n.properties.has(t)||n.properties.set(t,r);r=Object.getPrototypeOf(r)}return n}resolveUnionComponents(t){const e=new Map;for(const n of t){const t=p.get(n);if(!t)throw c(n);const r=t.entity.name;if(!r)throw m(n);e.set(r,n)}return e}};function h(t,e,n){if(u(n))return d(t,e,n);const r=p.getWithInheritance(n);if(!r)throw c(n);const o=e||r.entity.name;if(!o)throw m(n);const i=[],s={};for(const[e,o]of r.properties)y(n,t,o,e,i,s);return r.entity.xmlns&&(s.xmlns=r.entity.xmlns),{type:"element",name:o,attributes:s,elements:i}}function d(t,e,n){const r=f(n).marshal(t);return void 0===r?{}:{type:"element",name:e,elements:[{type:"text",text:r}]}}function y(t,e,n,r,o,i){n.comments?function(t,e,n){if(Array.isArray(t[e]))for(const r of t[e])n.push({type:"comment",comment:null==r?"":`${r}`})}(e,r,o):n.attr?function(t,e,n,r,o){if(!n.name)throw new Error(`xml-class-transformer: no name is specified for the property ${null==t?void 0:t.name}#${r}. Specify it with the @XmlAttribute({ name: '...' }) decorator.`);const i=w(e[r],n);if(void 0===i)return;o[n.name]=`${i}`}(t,e,n,r,i):n.chardata?function(t,e,n,r){const o=w(t[n],e);if(void 0===o)return;r.push({type:"text",text:o})}(e,n,r,o):n.array?function(t,e,n,r){if(null===t[n]||void 0===t[n])return;for(const o of t[n])if(e.marshaller||e.isPrimitiveType()){if(void 0===w(o,e))continue;r.push(d(o,e.name,String))}else{if(null==o)continue;const t=e.union?o.constructor:e.type();r.push(h(o,e.name,t))}}(e,n,r,o):n.marshaller||n.isPrimitiveType()?function(t,e,n,r,o){if(!n.name)throw new Error(`xml-class-transformer: no name is specified for property ${null==t?void 0:t.name}#${r}. Specify it with @XmlChildElem({ name: '...' }) decorator.`);const i=w(e[r],n);if(void 0===i)return;o.push(d(i,n.name,String))}(t,e,n,r,o):n.union?function(t,e,n){const r=t[e].constructor;n.push(h(t[e],void 0,r))}(e,r,o):function(t,e,n,r){void 0!==t[n]&&null!==t[n]&&r.push(h(t[n],e.name,e.type()))}(e,n,r,o)}function w(t,e){let n=t;if(e.marshaller)n=e.marshaller.marshal(t);else if(e.type){const r=e.type();u(r)&&(n=f(r).marshal(t))}return n}function v(t,e){if(u(e)){return function(t,e){const n=e?f(e):s,r="number"==typeof t?`${t}`:t;return n.unmarshal(r)}($(t),e)}const n=p.getWithInheritance(e);if(!n)throw new Error("Unknown class "+e);const r=new e;for(const[e,o]of n.properties)g(t,o,e,r);return r}function g(t,e,n,r){e.comments?function(t,e,n){const r=[];for(const e of t.elements||[])"comment"===e.type&&r.push(e.comment||"");n[e]=r}(t,n,r):e.attr?function(t,e,n,r){var o;if(!n.name)throw new Error(`xml-class-transformer: no name is specified for attribute ${e}. Specify it with @XmlAttribute({ name: '...' }) decorator.`);let i=null===(o=t.attributes)||void 0===o?void 0:o[n.name];"number"==typeof i&&(i=`${i}`);const s=b(i,n);r[e]=s}(t,n,e,r):e.chardata?function(t,e,n,r){const o=$(t),i=b(o,n);r[e]=i}(t,n,e,r):e.array?function(t,e,n,r){var o;if(n.union){const o=p.resolveUnionComponents(n.union()),i=[];for(const e of t.elements||[])if(e.name&&o.has(e.name)){const t=v(e,o.get(e.name));i.push(t)}r[e]=i}else{const i=(null===(o=t.elements)||void 0===o?void 0:o.filter((t=>t.name===n.name)))||[],s=[];for(const t of i){const e=v(t,n.type());s.push(e)}r[e]=s}}(t,n,e,r):e.union?function(t,e,n,r){var o;const i=p.resolveUnionComponents(n.union()),s=null===(o=t.elements)||void 0===o?void 0:o.find((t=>!!t.name&&i.has(t.name)));r[e]=s?v(s,i.get(s.name)):void 0}(t,n,e,r):function(t,e,n,r){var o;const i=null===(o=t.elements)||void 0===o?void 0:o.find((t=>t.name===n.name));if(n.marshaller||n.isPrimitiveType()){const t=b(i?$(i):void 0,n);r[e]=t}else r[e]=i?v(i,n.type()):void 0}(t,n,e,r)}function $(t){let e="";for(const n of t.elements||[])"text"===n.type&&n.text&&(e+=n.text||"");return e}function b(t,e){let n=t;if(e.marshaller)n=e.marshaller.unmarshal(t);else if(e.type){const r=e.type();u(r)&&(n=f(r).unmarshal(t))}return n}class x{}class E extends x{constructor(t){super(),Object.assign(this,t)}isPrimitiveType(){return!!this.type&&u(this.type())}}function X(t,e){return(n,r)=>{if("string"!=typeof r)throw new TypeError(`xml-class-transformer: Can't use @${t}({...}) decorator on a symbol property at ${n.constructor.name}#${r.toString()}`);if(!e.union&&!e.type&&!e.marshaller)throw new TypeError(`xml-class-transformer: No "type", "union" or "marshaller" was specified for the ${n.constructor.name}#${r.toString()}. Add it to the @${t}({...}) decorator.`);if(e.union&&e.type||e.union&&e.marshaller||e.type&&e.marshaller)throw new TypeError(`xml-class-transformer: The "union", "type" or "marshaller" options are not compatible with each other at ${n.constructor.name}#${r.toString()}. You can specify only one of them.`);if(e.union&&!e.union().length)throw new TypeError(`xml-class-transformer: The "union" option in @${t}({ ... }) can't be empty at ${n.constructor.name}#${r.toString()}. Either remove the "union" option or provide it with at least one type.`);if(e.union){if(e.name)throw new TypeError(`xml-class-transformer: The "union" option is not compatible with the "name" option at ${n.constructor.name}#${r.toString()}. XML element names for the union members should be specified at the union member classes.`)}else e.name=e.name||r;if(e.union){const i=e.union();if(i.find((t=>u(t))))throw new TypeError(`xml-class-transformer: unions of primitive types (String, Number, Boolean, BigInt or Date) are not supported. Fix it in the decorator @${t}({ union: ${o=i,"["+o.map((t=>{var e;return null!==(e=null==t?void 0:t.name)&&void 0!==e?e:`${o}`})).join(", ")+"]"}, ... }) at "${n.constructor.name}#${r.toString()}".`)}var o;p.setPropertyOptions(n.constructor,r,e)}}t.XmlAttribute=function(t){return X("XmlAttribute",new E(Object.assign(Object.assign({},t),{attr:!0})))},t.XmlChardata=function(t){return X("XmlChardata",new E(Object.assign(Object.assign({},t),{chardata:!0})))},t.XmlChildElem=function(t){return X("XmlChildElem",new E(t))},t.XmlComments=function(){return(t,e)=>{if("string"!=typeof e)throw new TypeError(`xml-class-transformer: Can't use @XmlComments({...}) decorator on a symbol property at ${t.constructor.name}#${e.toString()}`);p.setPropertyOptions(t.constructor,e,new E({comments:!0}))}},t.XmlElem=function(t){return e=>{if((t=t||{}).name=t.name||e.name,!t.name)throw m(e);return p.setEntityOptions(e,t),e}},t.classToXml=function(t,e){const n={elements:[h(t,"",t.constructor)]};return!1!==(null==e?void 0:e.declaration)&&("object"==typeof(null==e?void 0:e.declaration)&&null!==(null==e?void 0:e.declaration)?n.declaration=e.declaration:n.declaration={attributes:{version:"1.0",encoding:"UTF-8"}}),r.default.js2xml(n,e)},t.xmlToClass=function(t,e,n){var o;const i=null===(o=r.default.xml2js(t,Object.assign(Object.assign({},n),{compact:!1,alwaysArray:!0})).elements)||void 0===o?void 0:o[0];if(!i)throw new Error("No elements found in xml.");return v(i,e)},Object.defineProperty(t,"__esModule",{value:!0})}));
